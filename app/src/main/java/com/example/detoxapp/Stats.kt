package com.example.detoxappimport android.app.usage.UsageStatsManagerimport android.content.Contextimport android.os.Buildimport android.util.Logimport androidx.annotation.RequiresApiimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.*import androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.material3.Textimport androidx.compose.runtime.*import androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.platform.LocalContextimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.text.style.TextAlignimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport androidx.navigation.NavControllerimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.firestore.FirebaseFirestoreimport kotlinx.coroutines.tasks.awaitimport java.text.SimpleDateFormatimport java.util.*import kotlin.math.roundToInt@RequiresApi(Build.VERSION_CODES.LOLLIPOP)@Composablefun Statistics(navController: NavController, auth: FirebaseAuth, groupViewModel: GroupViewModel) {    val userId = auth.currentUser?.uid ?: return    val context = LocalContext.current    var selectedView by remember { mutableStateOf("Día") }    var selectedDay by remember { mutableStateOf(getTodayDate()) }    val usageHistory by produceState(initialValue = emptyList<DailyUsage>(), userId) {        value = fetchTimeUseData(context, userId).ifEmpty { generateFakeData() }    }    val fullWeekDates = remember { getFullCurrentWeekDates() }    val currentWeekUsage = usageHistory.filter { it.date in fullWeekDates.map { d -> d.first } }    val selectedDayData = usageHistory.find { it.date == selectedDay }?.apps ?: emptyMap()    val weekTotal = currentWeekUsage.sumOf { it.apps.values.sum() }    val dailyAverage = if (currentWeekUsage.isNotEmpty()) weekTotal / currentWeekUsage.size else 0L    val appsWeek = currentWeekUsage.flatMap { it.apps.entries }        .groupBy { it.key }        .mapValues { it.value.sumOf { e -> e.value } }        .filter { it.value >= 60_000 }        .toList()        .sortedByDescending { it.second }    LazyColumn(        modifier = Modifier            .fillMaxSize()            .background(Color.Black)            .padding(16.dp)    ) {        item {            Text(                text = "Estadísticas de uso",                color = Color.White,                fontSize = 24.sp,                fontWeight = FontWeight.Bold,                textAlign = TextAlign.Center,                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)            )        }        item {            Row(                modifier = Modifier                    .padding(8.dp)                    .background(Color.DarkGray, RoundedCornerShape(30.dp))                    .padding(4.dp)            ) {                listOf("Semana", "Día").forEach { option ->                    Box(                        modifier = Modifier                            .weight(1f)                            .background(                                if (selectedView == option) Color.Gray else Color.DarkGray,                                RoundedCornerShape(30.dp)                            )                            .clickable { selectedView = option }                            .padding(vertical = 8.dp),                        contentAlignment = Alignment.Center                    ) {                        Text(option, color = Color.White)                    }                }            }        }        item {            Spacer(modifier = Modifier.height(16.dp))        }        item {            if (selectedView == "Día") {                Box(                    modifier = Modifier                        .fillMaxWidth()                        .background(Color(0xFF1A1A1A), RoundedCornerShape(12.dp))                        .padding(16.dp)                ) {                    Column {                        val dayLabel = getReadableDayLabel(selectedDay)                        Text(dayLabel, color = Color.White, fontWeight = FontWeight.Bold)                        Spacer(modifier = Modifier.height(8.dp))                        Text("${formatTime(selectedDayData.values.sum())}", color = Color.White, fontSize = 20.sp)                        Spacer(modifier = Modifier.height(16.dp))                        Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {                            fullWeekDates.forEach { (date, label) ->                                val value = usageHistory.find { it.date == date }?.apps?.values?.sum() ?: 0L                                val maxTime = fullWeekDates.maxOfOrNull { d -> usageHistory.find { it.date == d.first }?.apps?.values?.sum() ?: 0L } ?: 1L                                val height = (value.toFloat() / maxTime * 100).coerceIn(0f, 100f)                                Column(                                    modifier = Modifier                                        .weight(1f)                                        .height(150.dp),                                    verticalArrangement = Arrangement.Bottom,                                    horizontalAlignment = Alignment.CenterHorizontally                                ) {                                    Box(                                        modifier = Modifier                                            .fillMaxWidth(0.5f)                                            .height(height.dp)                                            .background(                                                if (date == selectedDay) Color.Blue else Color.Gray,                                                RoundedCornerShape(4.dp)                                            )                                            .clickable { selectedDay = date }                                    )                                    Spacer(modifier = Modifier.height(4.dp))                                    Text(label, color = Color.White, fontSize = 12.sp)                                }                            }                        }                        Spacer(modifier = Modifier.height(8.dp))                    }                }                selectedDayData.entries.sortedByDescending { it.value }.forEach {                    AppUsageRow(AppUsage(it.key, it.value))                }            } else {                Box(                    modifier = Modifier                        .fillMaxWidth()                        .background(Color(0xFF1A1A1A), RoundedCornerShape(12.dp))                        .padding(16.dp)                ) {                    Column {                        Text("Media diaria", color = Color.White, fontWeight = FontWeight.Bold)                        Spacer(modifier = Modifier.height(8.dp))                        Text(formatTime(dailyAverage), color = Color.White, fontSize = 20.sp)                        Spacer(modifier = Modifier.height(16.dp))                        Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {                            fullWeekDates.forEach { (date, label) ->                                val value = usageHistory.find { it.date == date }?.apps?.values?.sum() ?: 0L                                val maxTime = fullWeekDates.maxOfOrNull { d -> usageHistory.find { it.date == d.first }?.apps?.values?.sum() ?: 0L } ?: 1L                                val height = (value.toFloat() / maxTime * 100).coerceIn(0f, 100f)                                Column(                                    modifier = Modifier                                        .weight(1f)                                        .height(150.dp),                                    verticalArrangement = Arrangement.Bottom,                                    horizontalAlignment = Alignment.CenterHorizontally                                ) {                                    Box(                                        modifier = Modifier                                            .fillMaxWidth(0.5f)                                            .height(height.dp)                                            .background(Color.Blue, RoundedCornerShape(4.dp))                                    )                                    Spacer(modifier = Modifier.height(4.dp))                                    Text(label, color = Color.White, fontSize = 12.sp)                                }                            }                        }                        Spacer(modifier = Modifier.height(8.dp))                        Text("Tiempo total de uso: ${formatTime(weekTotal)}", color = Color.White)                    }                }                appsWeek.forEach {                    AppUsageRow(AppUsage(it.first, it.second))                }            }        }    }}fun getReadableDayLabel(date: String): String {    val today = getTodayDate()    val cal = Calendar.getInstance()    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())    val inputDate = sdf.parse(date) ?: return date    val currentCal = Calendar.getInstance()    currentCal.time = sdf.parse(today)    return when {        date == today -> "Hoy, ${SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)}"        currentCal.apply { add(Calendar.DATE, -1) }.time == inputDate -> "Ayer, ${SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)}"        else -> SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)    }}fun getFullCurrentWeekDates(): List<Pair<String, String>> {    val cal = Calendar.getInstance()    cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)    val labels = listOf("L", "M", "X", "J", "V", "S", "D")    val result = mutableListOf<Pair<String, String>>()    for (i in 0..6) {        val date = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(cal.time)        result.add(date to labels[i])        cal.add(Calendar.DATE, 1)    }    return result}@Composablefun AppUsageRow(app: AppUsage) {    val hours = (app.usageTime / (1000 * 60 * 60)).toInt()    val minutes = ((app.usageTime / (1000 * 60)) % 60).toInt()    Row(        modifier = Modifier            .fillMaxWidth()            .padding(vertical = 8.dp)            .background(Color(0xFF222222), RoundedCornerShape(12.dp))            .padding(16.dp)    ) {        Column {            Text(text = app.appName, color = Color.White, fontSize = 18.sp)            Text(text = "${hours}h ${minutes}min", color = Color.Gray)        }    }}fun generateFakeData(): List<DailyUsage> {    val cal = Calendar.getInstance()    cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)    val today = Calendar.getInstance()    val apps = listOf("Instagram", "WhatsApp", "YouTube", "Chrome", "TikTok")    val fakeData = mutableListOf<DailyUsage>()    for (i in 0..6) {        val date = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(cal.time)        val usage = if (cal.before(today) || isSameDay(cal, today)) {            apps.associateWith { (30_000L..4 * 60 * 60 * 1000L).random() }        } else {            apps.associateWith { 0L }        }        fakeData.add(DailyUsage(date, usage))        cal.add(Calendar.DATE, 1)    }    return fakeData}fun isSameDay(cal1: Calendar, cal2: Calendar): Boolean {    return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)}fun getTodayUsageStats(context: Context): Map<String, Long> {    val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager    val cal = Calendar.getInstance().apply {        set(Calendar.HOUR_OF_DAY, 0)        set(Calendar.MINUTE, 0)        set(Calendar.SECOND, 0)        set(Calendar.MILLISECOND, 0)    }    val startTime = cal.timeInMillis    val endTime = System.currentTimeMillis()    val stats = usageStatsManager.queryUsageStats(        UsageStatsManager.INTERVAL_DAILY,        startTime,        endTime    )    return stats        .filter { it.totalTimeInForeground > 0 }        .associate { it.packageName to it.totalTimeInForeground }}fun saveTodayUsageToFirebase(context: Context, userId: String, onSuccess: (() -> Unit)? = null) {    val db = FirebaseFirestore.getInstance()    var usageMap = getTodayUsageStats(context)    val todayDate = getTodayDate()    if (usageMap.isEmpty()) {        val fakeApps = listOf("Instagram", "WhatsApp", "YouTube", "Chrome", "TikTok")        usageMap = fakeApps.associateWith { (15_000L..3 * 60 * 60 * 1000L).random() }        Log.d("FakeData", "Generando datos falsos para $todayDate: $usageMap")    }    val docRef = db.collection("users")        .document(userId)        .collection("time_use")        .document(todayDate)    docRef.set(usageMap)        .addOnSuccessListener {            Log.d("Firebase", "Datos guardados correctamente para $todayDate")            onSuccess?.invoke()        }        .addOnFailureListener { e ->            Log.e("Firebase", "Error guardando uso diario", e)        }}suspend fun fetchTimeUseData(context: Context, userId: String): List<DailyUsage> {    val db = FirebaseFirestore.getInstance()    saveTodayUsageToFirebase(context, userId)    val snapshot = db.collection("users").document(userId)        .collection("time_use")        .get()        .await()    return snapshot.documents.mapNotNull { doc ->        val date = doc.id        val data = doc.data ?: return@mapNotNull null        val usageMap = data.mapNotNull { (app, usage) ->            if (usage is Number) {                app to usage.toLong()            } else null        }.toMap()        DailyUsage(date, usageMap)    }.sortedBy { it.date }}