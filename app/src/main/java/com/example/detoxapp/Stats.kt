package com.example.detoxappimport android.app.AppOpsManagerimport android.app.usage.UsageEventsimport android.app.usage.UsageStatsManagerimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageManagerimport android.graphics.drawable.Drawableimport android.os.Buildimport android.util.Logimport android.widget.Toastimport androidx.annotation.RequiresApiimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.*import androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.material3.Textimport androidx.compose.runtime.*import androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.platform.LocalContextimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.text.style.TextAlignimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport androidx.navigation.NavControllerimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.firestore.FirebaseFirestoreimport kotlinx.coroutines.tasks.awaitimport java.text.SimpleDateFormatimport java.util.*import android.provider.Settingsimport androidx.compose.foundation.Imageimport androidx.compose.foundation.shape.CircleShapeimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.ArrowBackimport androidx.compose.material.icons.filled.ArrowForwardimport androidx.compose.material3.Iconimport androidx.compose.material3.IconButtonimport androidx.compose.ui.graphics.asImageBitmapimport androidx.core.graphics.drawable.toBitmapimport com.google.firebase.firestore.FieldPathimport kotlin.math.roundToInt@RequiresApi(Build.VERSION_CODES.LOLLIPOP)@Composablefun Statistics(auth: FirebaseAuth) {    val userId = auth.currentUser?.uid ?: return    val context = LocalContext.current    var selectedView by remember { mutableStateOf("Día") }    var selectedDay by remember { mutableStateOf(getTodayDate()) }    var today by remember { mutableStateOf(getTodayDate()) }    var currentCalendar by remember { mutableStateOf(Calendar.getInstance()) }    fun getWeekRange(calendar: Calendar): Pair<Date, Date> {        val cal = calendar.clone() as Calendar        cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)        val startDate = cal.time        cal.add(Calendar.DAY_OF_WEEK, 6)        val endDate = cal.time        return startDate to endDate    }    val oldestDateInFirebase = remember { mutableStateOf<Calendar?>(null) }    LaunchedEffect(Unit) {        if (!isUsageStatsPermissionGranted(context)) {            Toast.makeText(                context,                "Otorga permiso de acceso a uso para ver las estadísticas.",                Toast.LENGTH_LONG            ).show()            requestUsageStatsPermission(context)        }        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())        try {            val snapshot = FirebaseFirestore.getInstance()                .collection("users")                .document(userId)                .collection("time_use")                .orderBy(FieldPath.documentId())                .limit(1)                .get()                .await()            val docId = snapshot.documents.firstOrNull()?.id            docId?.let {                val date = sdf.parse(it)                if (date != null) {                    oldestDateInFirebase.value = date.toCalendar()                }            }        } catch (e: Exception) {            Log.e("Firestore", "Error fetching oldest date", e)        }    }    val (startDate, endDate) = getWeekRange(currentCalendar)    val usageHistory by produceState(initialValue = emptyList<DailyUsage>(), currentCalendar, userId) {        value = fetchTimeUseData(context, userId, startDate, endDate)    }    val fullWeekDates = remember(currentCalendar) {        val cal = currentCalendar.clone() as Calendar        cal.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)        (0 until 7).map {            val date = cal.time            val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())            val id = sdf.format(date)            val label = SimpleDateFormat("EEE", Locale.getDefault()).format(date)            cal.add(Calendar.DAY_OF_YEAR, 1)            id to label        }    }    val weekStartCalendar = (currentCalendar.clone() as Calendar).apply {        set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)        set(Calendar.HOUR_OF_DAY, 0)        set(Calendar.MINUTE, 0)        set(Calendar.SECOND, 0)        set(Calendar.MILLISECOND, 0)    }    val realCalendar = Calendar.getInstance().apply {        set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)        set(Calendar.HOUR_OF_DAY, 0)        set(Calendar.MINUTE, 0)        set(Calendar.SECOND, 0)        set(Calendar.MILLISECOND, 0)    }    val oldestMonday = oldestDateInFirebase.value?.clone() as? Calendar    oldestMonday?.apply {        set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)        set(Calendar.HOUR_OF_DAY, 0)        set(Calendar.MINUTE, 0)        set(Calendar.SECOND, 0)        set(Calendar.MILLISECOND, 0)    }    val canNavigateBack = oldestMonday != null && weekStartCalendar.after(oldestMonday)    val canNavigateForward = remember(usageHistory, currentCalendar) {        val nextWeek = (currentCalendar.clone() as Calendar).apply {            add(Calendar.DAY_OF_YEAR, 7)            set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)            set(Calendar.HOUR_OF_DAY, 0)            set(Calendar.MINUTE, 0)            set(Calendar.SECOND, 0)            set(Calendar.MILLISECOND, 0)        }        val weekDates = (0..6).map {            val cal = (nextWeek.clone() as Calendar).apply { add(Calendar.DAY_OF_YEAR, it) }            SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(cal.time)        }        val hasDataInWeek = usageHistory.any { it.date in weekDates }        val isNextWeekBeforeOrEqualToToday = !nextWeek.after(realCalendar)        hasDataInWeek || isNextWeekBeforeOrEqualToToday    }    // Función que actualiza el día seleccionado al más reciente con datos    fun updateSelectedDay() {        val currentWeekDays = fullWeekDates.map { it.first }        val latestDay = usageHistory            .filter { it.date in currentWeekDays }            .maxByOrNull { it.date }        val isThisWeek = weekStartCalendar.time == realCalendar.time        if (isThisWeek && usageHistory.any { it.date == today }) {            selectedDay = today        } else if (latestDay != null) {            selectedDay = latestDay.date        }    }    // Actualizar el día cada vez que cambie usageHistory    LaunchedEffect(usageHistory) {        updateSelectedDay()    }    fun navigateBack() {        if (canNavigateBack) {            currentCalendar = (currentCalendar.clone() as Calendar).apply {                add(Calendar.DAY_OF_YEAR, -7)            }        }    }    fun navigateForward() {        if (canNavigateForward) {            currentCalendar = (currentCalendar.clone() as Calendar).apply {                add(Calendar.DAY_OF_YEAR, 7)            }        }    }    val currentWeekUsage = usageHistory.filter { it.date in fullWeekDates.map { d -> d.first } }    val selectedDayData = usageHistory.find { it.date == selectedDay }?.apps ?: emptyMap()    val weekTotal = currentWeekUsage.sumOf { dailyUsage ->        dailyUsage.apps.values.filter { it >= 60_000L }.sum()    }    val dailyAverage = if (currentWeekUsage.isNotEmpty()) weekTotal / currentWeekUsage.size else 0L    val appsWeek = currentWeekUsage.flatMap { it.apps.entries }        .groupBy { it.key }        .mapValues { it.value.sumOf { e -> e.value } }        .filter { it.value >= 60_000L }        .toList()        .sortedByDescending { it.second }    val weekText = buildString {        val sdfDay = SimpleDateFormat("d", Locale.getDefault())        val sdfMonth = SimpleDateFormat("MMMM", Locale.getDefault())        val sdfYear = SimpleDateFormat("yyyy", Locale.getDefault())        val startDay = sdfDay.format(startDate)        val endDay = sdfDay.format(endDate)        val startMonth = sdfMonth.format(startDate)        val endMonth = sdfMonth.format(endDate)        val year = sdfYear.format(startDate)        if (startMonth == endMonth) {            append("$startDay - $endDay de $startMonth de $year")        } else {            append("$startDay de $startMonth - $endDay de $endMonth de $year")        }    }    LazyColumn(        modifier = Modifier            .fillMaxSize()            .background(Color.Black)            .padding(16.dp)    ) {        item {            Text(                "Estadísticas de uso",                color = Color.White,                fontSize = 24.sp,                fontWeight = FontWeight.Bold,                textAlign = TextAlign.Center,                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp)            )        }        item {            Row(                modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),                horizontalArrangement = Arrangement.SpaceBetween,                verticalAlignment = Alignment.CenterVertically            ) {                IconButton(                    onClick = {                        navigateBack()                    },                    enabled = canNavigateBack,                    modifier = Modifier                        .background(if (canNavigateBack) Color(0xFF2196F3) else Color.Gray, CircleShape)                        .size(32.dp)                ) {                    Icon(Icons.Default.ArrowBack, contentDescription = "Previous Week", tint = Color.White)                }                Text(weekText, color = Color.White, fontSize = 18.sp)                IconButton(                    onClick = {                        navigateForward()                    },                    enabled = canNavigateForward,                    modifier = Modifier                        .background(if (canNavigateForward) Color(0xFF2196F3) else Color.Gray, CircleShape)                        .size(32.dp)                ) {                    Icon(Icons.Default.ArrowForward, contentDescription = "Next Week", tint = Color.White)                }            }        }        item {            Row(                modifier = Modifier                    .padding(4.dp)                    .background(Color.DarkGray, RoundedCornerShape(30.dp))                    .padding(2.dp)            ) {                listOf("Semana", "Día").forEach { option ->                    Box(                        modifier = Modifier                            .weight(1f)                            .background(                                if (selectedView == option) Color.Gray else Color.DarkGray,                                RoundedCornerShape(30.dp)                            )                            .clickable { selectedView = option }                            .padding(vertical = 4.dp),                        contentAlignment = Alignment.Center                    ) {                        Text(option, color = Color.White)                    }                }            }        }        item { Spacer(modifier = Modifier.height(16.dp)) }        item {            if (selectedView == "Día") {                DayStatisticsView(selectedDay, fullWeekDates, selectedDayData, usageHistory) { selectedDay = it }            } else {                WeekStatisticsView(fullWeekDates, usageHistory, weekTotal, dailyAverage, appsWeek)            }        }    }}fun Date.toCalendar(): Calendar {    return Calendar.getInstance().apply { time = this@toCalendar }}@Composablefun DayStatisticsView(    selectedDay: String,    fullWeekDates: List<Pair<String, String>>,    selectedDayData: Map<String, Long>,    usageHistory: List<DailyUsage>,    onDaySelected: (String) -> Unit) {    Box(        modifier = Modifier            .fillMaxWidth()            .background(Color(0xFF1A1A1A), RoundedCornerShape(12.dp))            .padding(16.dp)    ) {        Column {            val dayLabel = getReadableDayLabel(selectedDay)            Text(dayLabel, color = Color.White, fontWeight = FontWeight.Bold)            Spacer(modifier = Modifier.height(8.dp))            val totalFilteredTime = selectedDayData.values.filter { it >= 60_000L }.sum()            Text("${formatTime(totalFilteredTime)}", color = Color.White, fontSize = 20.sp)            Spacer(modifier = Modifier.height(16.dp))            Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {                fullWeekDates.forEach { (date, label) ->                    val value = usageHistory.find { it.date == date }?.apps?.values?.filter { it >= 60_000L }?.sum() ?: 0L                    val maxTime = fullWeekDates.maxOfOrNull { d -> usageHistory.find { it.date == d.first }?.apps?.values?.filter { it >= 60_000L }?.sum() ?: 0L } ?: 1L                    val height = (value.toFloat() / maxTime * 100).coerceIn(0f, 100f)                    Column(                        modifier = Modifier.weight(1f).height(150.dp),                        verticalArrangement = Arrangement.Bottom,                        horizontalAlignment = Alignment.CenterHorizontally                    ) {                        Box(                            modifier = Modifier                                .fillMaxWidth(0.5f)                                .height(height.dp)                                .background(if (date == selectedDay) Color.Blue else Color.Gray, RoundedCornerShape(4.dp))                                .clickable { onDaySelected(date) }                        )                        Spacer(modifier = Modifier.height(4.dp))                        Text(label, color = Color.White, fontSize = 12.sp)                    }                }            }            Spacer(modifier = Modifier.height(8.dp))        }    }    selectedDayData.entries        .filter { it.value >= 60_000L }        .sortedByDescending { it.value }        .forEach {            AppUsageRow(AppUsage(it.key, it.value), LocalContext.current)        }}@Composablefun WeekStatisticsView(    fullWeekDates: List<Pair<String, String>>,    usageHistory: List<DailyUsage>,    weekTotal: Long,    dailyAverage: Long,    appsWeek: List<Pair<String, Long>>) {    Box(        modifier = Modifier            .fillMaxWidth()            .background(Color(0xFF1A1A1A), RoundedCornerShape(12.dp))            .padding(16.dp)    ) {        Column {            Text("Media diaria", color = Color.White, fontWeight = FontWeight.Bold)            Spacer(modifier = Modifier.height(8.dp))            Text(formatTime(dailyAverage), color = Color.White, fontSize = 20.sp)            Spacer(modifier = Modifier.height(16.dp))            Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {                fullWeekDates.forEach { (date, label) ->                    val value = usageHistory.find { it.date == date }?.apps?.values?.filter { it >= 60_000L }?.sum() ?: 0L                    val maxTime = fullWeekDates.maxOfOrNull { d ->                        usageHistory.find { it.date == d.first }?.apps?.values?.filter { it >= 60_000L }?.sum() ?: 0L                    } ?: 1L                    val height = (value.toFloat() / maxTime * 100).coerceIn(0f, 100f)                    Column(                        modifier = Modifier.weight(1f).height(150.dp),                        verticalArrangement = Arrangement.Bottom,                        horizontalAlignment = Alignment.CenterHorizontally                    ) {                        Box(                            modifier = Modifier                                .fillMaxWidth(0.5f)                                .height(height.dp)                                .background(Color.Blue, RoundedCornerShape(4.dp))                        )                        Spacer(modifier = Modifier.height(4.dp))                        Text(label, color = Color.White, fontSize = 12.sp)                    }                }            }            Spacer(modifier = Modifier.height(8.dp))            Text("Tiempo total de uso: ${formatTime(weekTotal)}", color = Color.White)        }    }    appsWeek.forEach {        AppUsageRow(AppUsage(it.first, it.second), LocalContext.current)    }}fun isUsageStatsPermissionGranted(context: Context): Boolean {    val appOps = context.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager    val mode = appOps.checkOpNoThrow(        AppOpsManager.OPSTR_GET_USAGE_STATS,        android.os.Process.myUid(),        context.packageName    )    return mode == AppOpsManager.MODE_ALLOWED}fun requestUsageStatsPermission(context: Context) {    context.startActivity(Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS).apply {        flags = Intent.FLAG_ACTIVITY_NEW_TASK    })}fun getReadableDayLabel(date: String): String {    val today = getTodayDate()    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())    val inputDate = sdf.parse(date) ?: return date    val currentCal = Calendar.getInstance()    currentCal.time = sdf.parse(today)    return when {        date == today -> "Hoy, ${SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)}"        currentCal.apply { add(Calendar.DATE, -1) }.time == inputDate -> "Ayer, ${SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)}"        else -> SimpleDateFormat("dd 'de' MMMM", Locale("es", "ES")).format(inputDate)    }}@Composablefun AppUsageRow(app: AppUsage, context: Context) {    val hours = (app.usageTime / (1000 * 60 * 60)).toInt()    val minutes = ((app.usageTime / (1000 * 60)) % 60).toInt()    val appName = remember(app.appName) { getAppNameFromPackage(context, app.appName) }    // Obtener el icono como Drawable y convertir a ImageBitmap    val iconBitmap = remember(app.appName) {        try {            context.packageManager.getApplicationIcon(app.appName)                .toBitmap()                .asImageBitmap()        } catch (e: PackageManager.NameNotFoundException) {            null        }    }    Row(        modifier = Modifier            .fillMaxWidth()            .padding(vertical = 8.dp)            .background(Color(0xFF222222), RoundedCornerShape(12.dp))            .padding(16.dp),        verticalAlignment = Alignment.CenterVertically,        horizontalArrangement = Arrangement.SpaceBetween    ) {        Column(modifier = Modifier.weight(1f)) {            Text(text = appName, color = Color.White, fontSize = 18.sp)            Text(text = "${hours}h ${minutes}min", color = Color.Gray)        }        if (iconBitmap != null) {            Image(                bitmap = iconBitmap,                contentDescription = "$appName icon",                modifier = Modifier.size(40.dp)            )        }    }}fun getAppNameFromPackage(context: Context, packageName: String): String {    val pm = context.packageManager    return try {        val flags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {            PackageManager.MATCH_UNINSTALLED_PACKAGES        } else {            0        }        val appInfo = pm.getApplicationInfo(packageName, flags)        if (!appInfo.enabled) {            // La app está deshabilitada, no podemos obtener nombre amigable            packageName        } else {            pm.getApplicationLabel(appInfo).toString()        }    } catch (e: PackageManager.NameNotFoundException) {        // No está instalada o no accesible        packageName    }}fun getTodayUsageStats(context: Context): Map<String, Long> {    val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager    val cal = Calendar.getInstance().apply {        set(Calendar.HOUR_OF_DAY, 0)        set(Calendar.MINUTE, 0)        set(Calendar.SECOND, 0)        set(Calendar.MILLISECOND, 0)    }    val startTime = cal.timeInMillis    val endTime = System.currentTimeMillis()    val events = usageStatsManager.queryEvents(startTime, endTime)    val usageMap = mutableMapOf<String, Long>()    var currentForegroundApp: String? = null    var lastForegroundTimestamp: Long = 0L    val event = UsageEvents.Event()    while (events.hasNextEvent()) {        events.getNextEvent(event)        when (event.eventType) {            UsageEvents.Event.MOVE_TO_FOREGROUND -> {                currentForegroundApp = event.packageName                lastForegroundTimestamp = event.timeStamp            }            UsageEvents.Event.MOVE_TO_BACKGROUND -> {                val duration = event.timeStamp - lastForegroundTimestamp                val packageName = currentForegroundApp                if (packageName != null && duration > 0) {                    usageMap[packageName] = usageMap.getOrDefault(packageName, 0L) + duration                }                currentForegroundApp = null                lastForegroundTimestamp = 0L            }        }    }    return usageMap}fun saveTodayUsageToFirebase(context: Context, userId: String, onSuccess: (() -> Unit)? = null) {    val db = FirebaseFirestore.getInstance()    var usageMap = getTodayUsageStats(context)    val todayDate = getTodayDate()    val docRef = db.collection("users")        .document(userId)        .collection("time_use")        .document(todayDate)    docRef.set(usageMap)        .addOnSuccessListener {            Log.d("Firebase", "Datos guardados correctamente para $todayDate")            onSuccess?.invoke()        }        .addOnFailureListener { e ->            Log.e("Firebase", "Error guardando uso diario", e)        }}suspend fun fetchTimeUseData(    context: Context,    userId: String,    startDate: Date,    endDate: Date): List<DailyUsage> {    val db = FirebaseFirestore.getInstance()    saveTodayUsageToFirebase(context, userId)    val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())    val startString = sdf.format(startDate)    val endString = sdf.format(endDate)    val snapshot = db.collection("users").document(userId)        .collection("time_use")        .whereGreaterThanOrEqualTo(FieldPath.documentId(), startString)        .whereLessThanOrEqualTo(FieldPath.documentId(), endString)        .get()        .await()    return snapshot.documents.mapNotNull { doc ->        val date = doc.id        val data = doc.data ?: return@mapNotNull null        val usageMap = data.mapNotNull { (app, usage) ->            if (usage is Number) {                app to usage.toLong()            } else null        }.toMap()        DailyUsage(date, usageMap)    }.sortedBy { it.date }}